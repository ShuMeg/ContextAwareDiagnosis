'''
Submitted 22.04.2022
Author: Aniruddha Jahagirdar

This module maps the predicted values generated by LSTM model to neo4j graph database, mapped values are analysed producing inferred
states, and getting the appropriate message from the application model for health check application.
'''

import random
from neo4j import GraphDatabase

# Configure Neo4j db
uri = "neo4j+s://0c5e103c.databases.neo4j.io"
username = "neo4j"
password = "b8HEnf1dgwy6D33Z6nBdjsgsN95KqgT3Ed0lHjvG2J0"
graph_db = "neo4j"

#Gets average values of accelerometer reading for the specified spin
def get_avg_acc_pre_values(session):
    query = """MATCH (n:n4sch_Acc_Pre_Value)
    RETURN AVG(apoc.convert.toInteger(n.n4sch_Value))"""
    value_result = session.run(query)
    return value_result

#Gets average values of noise reading for the specified spin
def get_avg_noise_pre_values(session):
    query = """MATCH (n:n4sch_Noise_Pre_Value)
    RETURN AVG(apoc.convert.toInteger(n.n4sch_Value))"""
    value_result = session.run(query)
    return value_result

#Gets average values of humidity reading for the specified spin
def get_avg_hum_pre_values(session):
    query = """MATCH (n:n4sch_Hum_Pre_Value)
    RETURN AVG(apoc.convert.toInteger(n.n4sch_Value))"""
    value_result = session.run(query)
    return value_result

#Gets Load weight for the specified spin
def get_avg_loadvalues(session):
    query = """MATCH (n:n4sch__LoadWeight)
    RETURN AVG(apoc.convert.toInteger(n.weight))"""
    value_load = session.run(query)
    return value_load

#Retrieves anomaly message and its components based on anomaly  
def get_anomaly_message(session, message_type):
    if message_type.lower() == "normal":
        #fetches normal message from neo4j database
        message = session.run("""MATCH (n:n4sch__Instance)
            WHERE n.n4sch__name = 'Normal_Prediction'
            RETURN n.message""")
    elif message_type.lower() == "accoverload":
        #fetches error message from neo4j database if Accelerometer reading is out of range and machine is overloaded
        message = session.run("""MATCH (n:n4sch__Instance)
            WHERE n.n4sch__name = 'Acc_Load_Prediction'
            RETURN n.message""")
    elif message_type.lower() == "accelerometer":
        #fetches error message from neo4j database if Accelerometer reading is out of range but machine is not overloaded
        message = session.run("""MATCH (n:n4sch__Instance)
            WHERE n.n4sch__name = 'Acc_Prediction'
            RETURN n.message""")
    elif message_type.lower() == "noiseoverload":
        #fetches error message from neo4j database if Noise reading is out of range and machine is overloaded
        message = session.run("""MATCH (n:n4sch__Instance)
            WHERE n.n4sch__name = 'Noise_Load_Prediction'
            RETURN n.message""")    
    elif message_type.lower() == "noise":
        #fetches error message from neo4j database if Noise reading is out of range but machine is not overloaded
        message = session.run("""MATCH (n:n4sch__Instance)
            WHERE n.n4sch__name = 'Noise_Prediction'
            RETURN n.message""")
    elif message_type.lower() == "humidity":
        #fetches error message from neo4j database if Humidity reading is out of range
        message = session.run("""MATCH (n:n4sch__Instance)
            WHERE n.n4sch__name = 'Hum_Prediction'
            RETURN n.message""")           
    else:
        pass
    return message

#Function to analysis predicted value readings
def health_check(uri, username, password, db_name):
    # Connect to graph database
    graph_driver = GraphDatabase.driver(uri, auth=(username, password))
    graph_session = graph_driver.session(database=db_name)
    print("connected")
    # Get program names
    query_res = graph_session.run("""MATCH (:n4sch__Class{n4sch__name:"Context"})<-[:n4sch__SCO]-(m)-[:IS_TYPE]-(n:n4sch__Instance) WHERE size(n.mode) > 2 
            RETURN DISTINCT n.mode""")
    programs = list()
    for item in query_res:
        programs.append(item[0])
    
    for selected_program in programs:
        program_results = list()
        if selected_program == "Health Check":
                # Get average Load value for pas spins
                query_avg_load_value = get_avg_loadvalues(graph_session)
                for item in query_avg_load_value:
                    avg_load_value = item[0]
                id1 = "pr" + str(random.randint(900, 900))
                # Query to delete old nodes to avoid duplication of nodes
                graph_session.run("""MATCH (n:n4sch_Acc_Pre_Value)
                                    DETACH DELETE n""")
                # Query to map new predicted values from csv to neo4j 
                graph_session.run("""LOAD CSV WITH HEADERS FROM "https://www.dropbox.com/s/2j4wbwj963eidmy/Acc_prediction.csv?raw=1" AS line
                                MERGE (m:n4sch_Acc_Pre_Value {n4sch_Value:line.Acc_Value, n4sch_name:'Acc Prediction', combo_id: $id})
                                RETURN m""", id=id1)
                # Query to to create relationship between values and Inferred Class of Context
                graph_session.run("""MATCH (n:n4sch__Instance), (m:n4sch_Acc_Pre_Value)
                                    WHERE n.n4sch__name = 'Acc_Predicted_Values' AND m.n4sch_name = 'Acc Prediction'
                                    CREATE (n)-[r:HAS_VALUE]->(m)
                                    RETURN r""")
                msg_list = list()
                query_avg_acc_pre_value = get_avg_acc_pre_values(graph_session)
                for item in query_avg_acc_pre_value:
                    avg_acc_value = item[0]
                if avg_acc_value < 4500:
                    # Get normal message
                    msg = get_anomaly_message(session=graph_session, message_type="Normal")
                else:
                    if avg_load_value > 5:
                        # Get overload anomaly message
                        msg = get_anomaly_message(session=graph_session, message_type="ACCoverload")
                    else:
                        # Get anomaly message
                        msg = get_anomaly_message(session=graph_session, message_type="Accelerometer")
                for item in msg:
                    msg_list.append(item[0])
                # Store results in dictionary
                subresult1= {'AccPrediction': avg_acc_value, 'AvgLoad': avg_load_value, 'Message': msg_list}
                id2 = "pr" + str(random.randint(950, 950))
                # Query to delete old nodes to avoid duplication of nodes
                graph_session.run("""MATCH (n:n4sch_Noise_Pre_Value)
                                    DETACH DELETE n""")
                # Query to map new predicted values from csv to neo4j 
                graph_session.run("""LOAD CSV WITH HEADERS FROM "https://www.dropbox.com/s/md34gmlo5sa87lf/Noise_prediction.csv?raw=1" AS line
                                MERGE (m:n4sch_Noise_Pre_Value {n4sch_Value:line.Noise_Value, n4sch_name:'Noise Prediction', unit:'dB', combo_id: $id})
                                RETURN m""", id=id2)
                # Query to to create relationship between values and Inferred Class of Context
                graph_session.run("""MATCH (n:n4sch__Instance), (m:n4sch_Noise_Pre_Value)
                                    WHERE n.n4sch__name = 'Noise_Predicted_Values' AND m.n4sch_name = 'Noise Prediction'
                                    CREATE (n)-[r:HAS_VALUE]->(m)
                                    RETURN r""")
                msg_list1 = list()
                query_avg_noise_pre_value = get_avg_noise_pre_values(graph_session)
                for item in query_avg_noise_pre_value:
                    avg_noise_value = item[0]
                if avg_noise_value < 80:
                    # Get normal message
                    msg = get_anomaly_message(session=graph_session, message_type="Normal")
                else:
                    if avg_load_value > 5:
                        # Get overload anomaly message
                        msg = get_anomaly_message(session=graph_session, message_type="Noiseoverload")
                    else:
                        # Get anomaly message
                        msg = get_anomaly_message(session=graph_session, message_type="Noise")
                for item in msg:
                    msg_list1.append(item[0])      
                # Store results in dictionary
                subresult2= {'NoisePrediction': avg_noise_value, 'AvgLoad': avg_load_value, 'Message': msg_list1}
                id = "pr" + str(random.randint(980, 980))
                # Query to delete old nodes to avoid duplication of nodes
                graph_session.run("""MATCH (n:n4sch_Hum_Pre_Value)
                                                DETACH DELETE n""")
                # Query to map new predicted values from csv to neo4j
                graph_session.run("""LOAD CSV WITH HEADERS FROM "https://www.dropbox.com/s/rrlcmfjkx6elxfn/Hum_prediction.csv?raw=1" AS line
                                MERGE (m:n4sch_Hum_Pre_Value {n4sch_Value:line.Hum_Value, n4sch_name:'Hum Prediction', combo_id: $id})
                                RETURN m""", id=id)
                # Query to to create relationship between values and Inferred Class of Context
                graph_session.run("""MATCH (n:n4sch__Instance), (m:n4sch_Hum_Pre_Value)
                                    WHERE n.n4sch__name = 'Hum_Predicted_Values' AND m.n4sch_name = 'Hum Prediction'
                                    CREATE (n)-[r:HAS_VALUE]->(m)
                                    RETURN r""") 
                msg_list2 = list()    
                query_avg_hum_pre_value = get_avg_hum_pre_values(graph_session)
                for item in query_avg_hum_pre_value:
                    avg_hum_value = item[0]
                if avg_hum_value < 18:
                    # Get normal message
                    msg = get_anomaly_message(session=graph_session, message_type="Normal")
                else:
                    # Get anomaly message
                    msg = get_anomaly_message(session=graph_session, message_type="Humidity")
                for item in msg:
                    msg_list2.append(item[0])   
                # Store results in dictionary
                subresult3= {'HumPrediction': avg_hum_value, 'Message': msg_list2}       
    graph_session.close()
    program_results.append(subresult1)
    program_results.append(subresult2)
    program_results.append(subresult3)    
    return program_results